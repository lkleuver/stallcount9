<?php

/**
 * Stage
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Stage extends BaseStage{

	public function getNextRank() {
		$rank = 1;
		foreach($this->Pools as $pool) {
			if($pool->rank >= $rank) {
				$rank = $pool->rank + 1;
			}
		}
		return $rank;
	}
	
	
	public function schedule() {
		FB::group("::::: STAGE ".$this->title." :::::::");
		foreach($this->Pools as $pool) {
			$pool->schedule();
		}		
		FB::groupEnd();
	}
	
	/**
	 * 
	 * executes moves
	 */
	public function performMoves() {
		foreach($this->Pools as $pool) {
			$pool->performMoves();
		}
	}
	
	/**
	 * 
	 * Number of teams in this Stage
	 * @return int
	 */
	public function getTeamCount() {
		$result = 0;
		foreach($this->Pools as $pool) {
			$result += $pool->getTeamCount();
		}
		return $result;
	}
	
	/**
	 * 
	 * number of teams that will qualify for the next round
	 * @return int
	 */
	public function getQualifiedTeamCount() {
		$result = 0;
		foreach($this->Pools as $pool) {
			$result += $pool->getQualifiedTeamCount();
		}
		return $result;
	}
	
	/**
	 * 
	 * check if all matches in this stage are played
	 * @return Boolean
	 */
	public function isFinished() {
		foreach($this->Pools as $pool) {
			if(!$pool->isFinished()) {
				return false;
			}
		}
		return true;
	}

	public function getParentStage() {
		$result = null;
		for($i = 0; $i < count($this->Division->Stages); $i++) {
			if($this->Division->Stages[$i]->id == $this->id) {
				if($i > 0) {
					$result = $this->Division->Stages[$i - 1]; 
				}
				break;
			}
		}
		
		return $result;
	}
	
	public function getQualifiedTeams() {
		$result = array();
		foreach($this->Pools as $pool) {
			$qualifiedPoolTeams = $pool->getQualifiedTeams();
			foreach($qualifiedPoolTeams as $team) $result[] = $team;
		}
		return $result;
	}
	
	public function seedWithTeams($seedTeams) {
		echo "Seeding:<br />";
		foreach($seedTeams as $team) {
			echo $team->id."<br />";
		}
		exit;
	}
	
	
	public function getActiveRound() {
		// returns the smallest currentRound of all Pools of this stage
		
		$result = 0;
		foreach($this->Pools as $pool) {
			if($result == 0 || $pool->currentRound < $result) {
				$result = $pool->currentRound;
			}
		}
		return $result;
	}
	
	public function finalSMS() {
		// works only if this is a placement state
		assert($this->placement);
		// creates SMS for teams that have finished the tournament
		foreach($this->Pools as $pool) {
			if ($pool->isFinished()) {
				foreach($pool->PoolTeams as $poolTeam) {
					$this->createPlacementSMSForTeam($pool->Rounds[count($pool->Rounds)-1],$poolTeam->rank+$pool->offsetRank(),$poolTeam->Team);
				}
			}
		}		
	}

	private function createPlacementSMSForTeam($lastRound,$rank,$team) {
		
		// After a 15-2 loss in the final game, you finish Windmill 2010 in place 1. Congratulations!
        // Please hand in today's spirit scores and see you next year!
				
		// After a 13-12 win in the exciting final, you are the champion of Windmill 2010. Congratulations!"
		// After a 11-18 loss in the final, you are vice-champion of Windmill 2010. Congratulations!"
		
		// check if the next game is "tomorrow"

		$text = "After a ";
		$text .= Round::getResultInRound($lastRound,$team->id);
		$text .= ' in the final game, you finish Windmill 2011 in place '.$rank.'.';
		$text .= "Congratulations!Please hand in today's spirit scores and see you next year!";
	
		FB::group('sms for team '.$team->name.':');
		FB::log($text);
		$sms = New SMS();
		$sms->message = $text;
		$sms->createTime=time();
		$sms->link('Team', array($team->id));
		$sms->link('Tournament',array($lastRound->Pool->Stage->Division->tournament_id));
		//$sms->link('Round',array($round->id));	
		$sms->save();
			
		FB::groupEnd();
	}
	
	
	public static function getById($id) {
		$q = Doctrine_Query::create()
			    ->from('Stage s')
			    ->leftJoin('s.Division d')
			    ->leftJoin('s.Pools p')
			    ->where('s.id = ?', $id)
			    ->orderBy('s.rank ASC, p.rank ASC');
		$stage = $q->fetchOne();
		return $stage;
	}
	
}